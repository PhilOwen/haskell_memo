Rの構文を、Haskellにインラインで埋め込みつつ、
そこのRで評価された値をちゃんと受け取ってみる。

結論から言うと、あまり良くなかった。
Rの値をHaskellに取り出すのが、必要以上に複雑。
あと、Macだとちょっとした問題があり、Dockerとも組み合わせることで回避した。  
そんな感じなので、Rから値を戻すときは、素直にファイルなどを介するのが無難。
（Rを使うとき、リアルタイム性はあまり求められないはずだし）

## やったこと
Haskell->Rを一方的に呼んで、
値を返さないようだとあまり面白くない。
それだと別プロセスでRを起動して、
コマンドラインオプションやファイルを
介してパラメータを渡せばいいので。
なので、 **Rから、Hsプログラム内でちゃんと値を受け取る** ところまでやってみた。

値を返すこの処理が、**予想以上に面倒** だった。
Haskell->Rの変換なら、型が ***厳密*** な方から ***ゆるい*** 方へ行くのでラク。
だが、R内で作った単純な`42`をHaskellへ
取り出すのすら、結構まわりくどい。  
Rの内部表現を、プログラマがある程度考えて、
Haskellへ取り出さないといけない。
Rモナドや関連する型やらを多少理解する必要があった。
（今でもあまり理解していない…）

今回は、数値と、数値のリストも取り出した。
とはいえ、Rをちょっとインラインで使う用途では、
数値と数値リストを返せるだけでも、だいたい大丈夫だと思う。
（Rを使うとき、構造体とかあんまり意識しないはずなので）

なお、Rでは数値はデフォルトで浮動小数点数。
整数は、明示しないと出てこない。


あと、inline-rとMac OS上のCヘッダが
何か相性が良くないらしく、
そのままではMacでコンパイルが通らなかった。
stackはDockerを標準でサポートしているので、
この際Mac直接はやめて、docker上でプログラムを実行することにした。

`stack.yaml`内で

    docker:  
        enable: true

とやっておく。
その後、`stack docker pull`しておくこと。
これで、stackの標準Dockerイメージが`pull`され、
それ以降、普通に`stack build`等できるようになる。


あと、この記事を初めて描いたときは
inline-rがstackageに含まれていたが、
2018/8に見たらなくなっていた。
`stack.yaml`で参照を追加するとか、
多少細工する必要があった。
（色々とハードル高い…）

## References
- [inline-rでの型キャスト](https://tweag.github.io/HaskellR/docs/casts-and-coercions.html)
- [stackとdocker](https://docs.haskellstack.org/en/stable/docker_integration/)
